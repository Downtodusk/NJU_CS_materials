# 🔗关系数据库规范化理论

- 基于函数依赖的关键字定义: $K\; {\rarr} \; U$ ,则K是关键字
- 属性集闭包的计算方法 : 不断推导 :cry: 

- 关键字:key:的计算方法: 

  - 1. $Armstrong$公理推导
    2. 闭包: 计算能够满足条件$（K_F^+ = U）$的最小属性集合K
       - $Alg1$ : 一开始**集合(判断该元素是否为关键字的集合)**中只有一个元素, 然后利用F逐步扩大, 直到集合不发生变化
       - $Alg2$ : 一开始**集合(单次判断出一组关键字的集合)**中为全集, 然后尝试除去集合中的每个元素,看除去后的集合能否推导出U
    3. 先计算最小覆盖简化过程, 这样算法1, 2的计算过程能够得到简化

- 理解概念:

  <img src="C:\Users\Jsissosix\AppData\Roaming\Typora\typora-user-images\image-20250105181635410.png" alt="image-20250105181635410" style="zoom: 50%; margin-left: 0;" />

#### 规范化理论

- 1NF : 关系模式 $R(U)$ 中的每个属性值都是一个**不可分割**的数据量
- 2NF : 不存在部分函数依赖 **部分依赖**
- 3NF : 非主属性不能依赖于其他非主属性 **传递依赖**
- BCNF : 每一个决定因素都是候选键 **3NF加强版**
- 4NF : 消除非平凡的**多值依赖**

#### Min Cover

- 最小函数依赖集的判断: <font color='purple'>**不存在冗余依赖 + 不存在部分依赖**</font>

- 算法:
  ***Step1.*** 确保$X\rarr Y$的$Y$为单个属性
  
  ***Step2.*** 移除冗余: 移除一项函数依赖, 如果移除后的闭包=移除前的闭包 
  
  ***Step3.*** 移除部分: 对每一项左侧有多个值的函数依赖, 替换左侧为它们的真子集, 如果不改变闭包
  
  ***Step4.*** 对于当前的函数依赖$FDs$, 利用合并规则合并 (例如$X\rarr Y$, $X\rarr Z$合并为$X\rarr YZ$)

> [!NOTE]
>
> 函数依赖集F的最小覆盖并不具有唯一性(写出一种即可)

#### 模式分解

- 无损连接性: 分解后，原关系中的信息不会被丢失
  - 充要条件: 分解后的重合属性至少能决定一侧的独有属性，即：$R_1\cap R_2 \rarr (R_1-R_2) \quad or \quad R_1\cap R_2 \rarr (R_2-R_1)$
- 依赖保持性 : 原有的**函数依赖关系**在分解后的关系模式上依然存在

> **在必须同时满足无损联接性和依赖保持性的要求下，一个关系模式最高可以被分解到满足3NF。**

- 分解算法 : 
  - 计算最小函数依赖集
  - 为每个函数依赖创建一个子关系
  - 检查候选键并覆盖主属性集
  - <font color='gray'>验证无损连接性</font>
