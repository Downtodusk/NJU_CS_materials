#### 三种并发问题

- **丢失修改** : 一个事务的修改结果破坏了另一个事务的修改结果
- **脏读** : 读到了错误的数据, 一个事务读取了另一个事务未提交的修改结果
- **不可重复读** : 在一个事务的执行过程中，前后两次读同一个数据对象所获得的值出现了不一致, 两次**Read**之间插入了一个**Write**

#### 冲突

- **同一事务**中的任意两个操作是冲突
- 不同事物满足以下两个条件是冲突:
  - 涉及<font color='ORANGE'>**同一个数据对象**</font>
  - 至少有一个是<font color='ORANGE'>**写**</font>操作

#### 可串行化调度

通过一组**非冲突**操作的交换，能够将该调度转换为一个串行调度，则我们认为最初的调度就是一个可串行化调度

#### 封锁协议

- 一阶段: 写之前必须获得X锁, 事务结束后才能释放                `-->` 丢失修改
- 二阶段: 一阶段 + 在读之前必须获得S锁, **读完成**即可释放      `-->` 丢失修改, 脏读
- 三阶段: 一阶段 + 在读之前必须获得S锁, **事务结束**后才能释放 `-->` 丢失修改, 脏读, 不可重复读

#### 2PL协议

- 第一个阶段 : 申请并获得锁
  - **扩展阶段**
- 第二个阶段 : 释放所有申请获得的锁
  - **收缩阶段 : 一旦开始释放封锁，那么就不能再申请任何封锁**

#### 封锁粒度

封锁粒度越**大**, 系统并发度越**低**, 并发控制的开销越**小**

#### 日志

##### Undo日志

从日志尾部向头部扫描,对于每一条更新记录,进行判断:

- 已经提交的日志(有commit)不用处理

- 没有commit的日志执行undo
- **对于每个未结束事务,在日志尾部加上`<Abort T>`并`flush log`**

> 先写磁盘后`commit`

##### 带checkpoint的undo日志

- 非静止检查点+先遇到startcheckpoint: 继续扫描直到checkpoint里的事务全部撤销(除了已经commit的)

##### redo日志

从日志首部开始扫描,对于每一条更新记录,进行判断:

- 忽略未提交事务
- 对于已提交事务,进行重做
- **对于每个未完成事务,在日志尾部加上`<Abort T>`并`flush log`**

> 先`commit`后写磁盘

##### Undo/redo日志

- 从尾部向头部扫描: 撤销未结束的事务
- 从头部向尾部扫描: 重做已提交的事务

> 确保更新记录出现在磁盘上后写磁盘, commit和写磁盘的顺序无所谓
>
> 每一条commit后必须紧跟flush log
